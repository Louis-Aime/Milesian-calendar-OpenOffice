<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="MilesianCalendar" script:language="StarBasic">REM  *****  BASIC  *****

&apos;Milesian Calendar: Enter and display dates in Open Office Calc following Milesian calendar conventions
&apos;Copyright Miletus SARL 2018. www.calendriermilesien.org
&apos;For use as a Basic module.
&apos;Extended after the same module in VBA
&apos; -&gt; MacOS epoch not taken into account (no way to reach the parameter)
&apos;Tested under LibreOffice Calc V5.0.
&apos;No warranty.
&apos;May be used for personal or professional purposes.
&apos;If transmitted or integrated, even with changes, present header shall be maintained in full.
&apos;Functions are aimed at extending Date &amp; Time functions, and use similar parameters syntax in English
&apos;Version V1.1 M2018-02-10
&apos;
Const MStoPresentEra As Long = 986163 &apos;Offset between 1/1m/-800 epoch and Microsoft origin (1899-12-31T00 is 1)
Const MStoJulianMinus05 As Long = 2415018 &apos;Offset between julian day epoch and Microsoft origin, minus 0.5
Const HighYear = 10000
Const LowYear = -10000
Const InvArgMsg = &quot;Err :502&quot;	&apos;Error message displayed in place of function result, for non-typed functions
Const InvalidNumber = 11968268  &apos;A high number to be set for wrong values of entry parameters, for typed functions


&apos;#Part 1: internal procedures

Sub Milesian_IntegDiv(ByVal Dividend As Long, ByVal Divisor As Long, Cycle As Long, Phase As Long)
&apos;Quotient and modulo in the same operation. Divisor shall by positive.
&apos;Cycle (i.e. Quotient) is same sign as Dividend. 0 &lt;= Phase (i.e. modulo) &lt; Divisor.
Cycle = 0
Phase = Dividend
If Divisor &gt; 0 Then
 While Phase &lt; 0
   Phase = Phase + Divisor
   Cycle = Cycle - 1
   Wend
 While Phase &gt;= Divisor
    Phase = Phase - Divisor
    Cycle = Cycle + 1
    Wend
Else
	Cycle = InvalidNumber
	Phase = InvalidNumber
End If
End Sub

Sub Milesian_IntegDivCeiling(ByVal Dividend As Long, ByVal Divisor As Long, ByVal ceiling As Integer, Cycle As Long, Phase As Long)
&apos;Quotient and modulo in the same operation. By exception, remainder may be = divisor if quotient = ceiling
&apos;Cycle (i.e. Quotient) is same sign as Dividend. 0 &lt;= Phase (i.e. modulo) &lt;= Divisor.
Cycle = 0
Phase = Dividend
If Divisor &gt; 0 And Dividend &gt;= 0 And Dividend &lt;= ceiling * Divisor + 1 Then
 ceiling = ceiling - 1 &apos;Decrease ceiling by 1 in order to simplify test in the next loop
 While (Phase &gt;= Divisor) And Cycle &lt; ceiling
 Phase = Phase - Divisor
 Cycle = Cycle + 1
 Wend
Else
	Cycle = InvalidNumber
	Phase = InvalidNumber
End If
End Sub

Private Function PosDiv (ByVal A, D) &apos;The Integer division with positive remainder
PosDiv = 0
  If D &lt;= 0 Then 
	PosDiv = InvArgMsg
  Else
	While (A &lt; 0)
		A = A + D
		PosDiv = PosDiv - 1
	Wend
	While (A &gt;= D)
		A = A - D
		PosDiv = PosDiv + 1
	Wend
  End If
End Function

Private Function PosMod(ByVal A, D)  &apos;The always positive modulo, even if A&lt;0
    If D &lt;= 0 Then
        PosMod = InvArgMsg
    Else
        While (A &lt; 0)
            A = A + D
        Wend
        While (A &gt;= D)
            A = A - D
        Wend
    PosMod = A
    End If
End Function

&apos;#Part 2: a function used internally, but available to user

Function MILESIAN_IS_LONG_YEAR(ByVal Year) As Boolean
&apos;Is year Year a 366 days year, i.e. a year just before a bissextile year following the Milesian rule.
&apos;Search for any value of year, provided that year are on a continuous degree
On Error Goto ErrorHandler
  If Year &lt;&gt; Int(Year) Or Year &lt; LowYear Or Year &gt; HighYear Then Goto ErrorHandler &apos;Check that we have an integer numeric value
  Year = Year + 1
  MILESIAN_IS_LONG_YEAR = PosMod (Year,4) = 0 And (PosMod (Year,100) &lt;&gt; 0 Or (PosMod(Year, 400) = 0 And PosMod(Year+800, 3200) &lt;&gt; 0))
  Exit Function
ErrorHandler:
  MILESIAN_IS_LONG_YEAR = False
End Function

&apos;#Part 3: Compute date from milesian parameters

Function MILESIAN_DATE(Year, Month, DayInMonth) As Long &apos;Date set as a long integer, without time element
&apos;Date number from a Milesian date given as year (positive or negative), month, daynumber in month
&apos;Result is forced to a long number, elsewhise an ambiguous string is created.
  On Error Goto ErrorHandler
  Dim A As Integer &apos;Intermediate computations as non-long integer
  Dim B As Long   &apos;Bimester number, for intermediate computations
  Dim M1 As Long  &apos;Month rank
  Dim D As Long   &apos;Days expressed in long integer
&apos;Check that Milesian date is OK
If Year &lt;&gt; Int(Year) Or Month &lt;&gt; Int(Month) Or DayInMonth &lt;&gt; Int (DayInMonth) Then Goto ErrorHandler
  If Year &gt;= LowYear And Year &lt;= HighYear And Month &gt; 0 And Month &lt; 13 And DayInMonth &gt; 0 And DayInMonth &lt; 32 Then &apos;Basic filter
	M1 = Month - 1 &apos;Count month rank, i.e. 0..11
	Milesian_IntegDiv M1, 2, B, M1 &apos;B = full bimesters, M1 = 1 if a full month added, else 0
	If DayInMonth &lt; 31 Or (M1 = 1 And (B &lt; 5 Or MILESIAN_IS_LONG_YEAR(Year))) Then
	  Year = Year + 800    &apos;Set Epoch to the year -800
	  A = PosDiv (Year, 4) - PosDiv(Year, 100) + PosDiv(Year, 400) - PosDiv(Year, 3200) &apos;Sum non-long terms: leap days
	  D = Year            &apos;Force long-integer conversion
	  D = D * 365      &apos;Begin computation of days in long-integer;
	  D = D - MStoPresentEra - 1 + B * 61 + M1 * 30 + A + DayInMonth &apos;Computations in long-integer first
	  MILESIAN_DATE = D
	Else	&apos; Case where date elements do not build a correct milesian date
	  MILESIAN_DATE = InvalidNumber+1	
	End If
  Else		&apos; Case where the date elements are outside basic values
	MILESIAN_DATE = InvalidNumber+2
  End If
Exit Function
ErrorHandler:
  MILESIAN_DATE = InvalidNumber+3
End Function

Function MILESIAN_YEAR_BASE(ByVal Year) As Long &apos;The Year base or Doomsday of a year i.e. the date just before the 1 1m of the year
On Error Goto ErrorHandler
If Year &lt;&gt; Int(Year) Or Year &lt; LowYear Or Year &gt; HighYear Then Goto ErrorHandler
Dim A As Integer, D As Long   &apos;Force long integer
Year = Year + 800    &apos;Set Epoch to the year -800
D = Year            &apos;Force long-interger conversion
D = D * 365      &apos;Begin computation of days in long-integer;
A = PosDiv (Year, 4) - PosDiv(Year, 100) + PosDiv(Year, 400) - PosDiv(Year, 3200)
D = D - MStoPresentEra + A - 1           &apos;Computations in long-integer first
MILESIAN_YEAR_BASE = D
Exit Function
ErrorHandler: 
MILESIAN_YEAR_BASE = InvalidNumber
End Function

&apos;#Part 4: Extract Milesian elements from Date number

Sub Milesian_DateElement(DNum As Date, Y As Integer, M As Integer, Q As Integer, T As Variant)
&apos; From DNum, a Date object, compute the milesian date Q / M / Y (day in month, month, year)
&apos; Y is year in common era, relative value (may be 0 or negative)
&apos; M is milesian month number, 1 to 12
&apos; Q is number of day in month, 1 to 31
&apos; T is positive decimal part: the time.
&apos; This is an internal subroutine. Corresponding functions come after.
Dim Cycle As Long, Day As Long      &apos;Cycle is used serveral times with a different meaning each time
Day = Int(DNum)                      &apos;Initiate Day as highest integer lower or equal to DNum (force Dnum to its numeric expression)
T = DNum - Day		&apos; Time part, 0 &lt;= T &lt; 1
Day = Day + MStoPresentEra
Milesian_IntegDiv Day, 1168775, Cycle, Day   &apos;Day is day rank in Milesian era (starting from 1/1m/-800), Cycle is era (0 begins 1/1/-800)
Y = -800 + Cycle * 3200
Milesian_IntegDiv Day, 146097, Cycle, Day    &apos;Day is day rank in 400 years period, Cycle is quadrisaeculum
Y = Y + Cycle * 400
Milesian_IntegDivCeiling Day, 36524, 4, Cycle, Day   &apos;Day is day rank in century, Cycle is rank of century
Y = Y + Cycle * 100
Milesian_IntegDiv Day, 1461, Cycle, Day              &apos;Day rank in quadriannum
Y = Y + Cycle * 4
Milesian_IntegDivCeiling Day, 365, 4, Cycle, Day     &apos;Day rank in year
Y = Y + Cycle
Milesian_IntegDiv Day, 61, Cycle, Day             &apos;Day rank in bimester
M = 2 * Cycle
Milesian_IntegDivCeiling Day, 30, 2, Cycle, Day  &apos;Day: day rank within month, Cycle = month rank in bimester
M = M + Cycle + 1                       &apos;M: month number, 1 to 12
Q = Day + 1                             &apos;Q: day number within month, 1 to 31
End Sub

Function MILESIAN_YEAR(TheDate)  &apos;The milesian year (common era) for a Date argument (a series number or a string)
On Error Goto ErrorHandler
Dim Y As Integer, M As Integer, Q As Integer, T As Variant
&apos;Dim NumDate as Date
&apos;NumDate = TheDate &apos;Force conversion or raise error
Milesian_DateElement TheDate, Y, M, Q, T   &apos;Compute the figures of the milesian date
MILESIAN_YEAR = Y
Exit Function
ErrorHandler: 
MILESIAN_YEAR = InvArgMsg
End Function

Function MILESIAN_MONTH(TheDate)   &apos;The milesian month number (1-12) for a Date argument
On Error Goto ErrorHandler
Dim Y As Integer, M As Integer, Q As Integer, T As Variant
Milesian_DateElement TheDate, Y, M, Q, T   &apos;Compute the figures of the milesian date
MILESIAN_MONTH = M
Exit Function
ErrorHandler:  
MILESIAN_MONTH = InvArgMsg
End Function

Function MILESIAN_DAY(TheDate)  &apos;The day number in the milesian month for a Date argument
On Error Goto ErrorHandler
Dim Y As Integer, M As Integer, Q As Integer, T As Variant
Milesian_DateElement TheDate, Y, M, Q, T   &apos;Compute the figures of the milesian date
MILESIAN_DAY = Q
Exit Function
ErrorHandler:  
MILESIAN_DAY = InvArgMsg
End Function

Function MILESIAN_TIME(TheDate)
On Error Goto ErrorHandler
Dim Y As Integer, M As Integer, Q As Integer, T As Variant
Milesian_DateElement TheDate, Y, M, Q, T   &apos;Compute the figures of the milesian date
MILESIAN_TIME = T
Exit Function
ErrorHandler:  
MILESIAN_TIME = InvArgMsg
End Function

Function MILESIAN_DISPLAY(TheDate, Optional Wtime) As String &apos;Default =False does not work
&apos;Milesian date as a string, for a Date argument
On Error Goto ErrorHandler
Dim Y As Integer, M As Integer, Q As Integer, T As Variant
If IsMissing(Wtime) Then Wtime = 1
&apos;Dim NumDate as Date
&apos;NumDate = TheDate &apos;Force conversion or raise error
Milesian_DateElement TheDate, Y, M, Q, T  &apos;Compute the figures of the milesian date
MILESIAN_DISPLAY = Q &amp; &quot; &quot; &amp; M &amp; &quot;m &quot; &amp; Y
If Wtime = 1 Then MILESIAN_DISPLAY = MILESIAN_DISPLAY &amp; &quot; &quot; &amp; T
Exit Function
ErrorHandler: 
MILESIAN_DISPLAY = InvArgMsg
End Function

&apos;#Part 5: Computations on milesian months

Function MILESIAN_MONTH_SHIFT(TheDate, MonthShift As Long) As Long &apos;Same date several (milesian) months later of earlier
On Error Goto ErrorHandler &apos;Error comes from wrong parameter
Dim Y As Integer, M As Integer, Q As Integer, T As Variant, NumDate as Date
Dim M1 As Long, Cycle As Long, Phase As Long
NumDate = TheDate &apos;Force conversion or raise error
Milesian_DateElement NumDate, Y, M, Q, D   &apos;Compute the figures of the milesian date
&apos;Compute month rank from 1m of year 0
M1 = Y                     &apos; Force computation of month in Long
M1 = (M1 * 12) + MonthShift + M - 1 &apos;In this order, Long shall be before simple Integer
&apos;Compute year and month rank
Milesian_IntegDiv M1, 12, Cycle, Phase
Y = Cycle
M = Phase + 1
&apos;If Q was 31, set to end of month, else use same day number
If (Q = 31) And (((M Mod 2) = 1) Or ((M = 12) And Not MILESIAN_IS_LONG_YEAR(Y))) Then Q = 30
MILESIAN_MONTH_SHIFT = MILESIAN_DATE(Y, M, Q)
Exit function
ErrorHandler:
MILESIAN_MONTH_SHIFT = InvalidNumber
End Function

Function MILESIAN_MONTH_END(TheDate, MonthShift As Long) As Long &apos;End of month several (milesian) months later of earlier
On Error Goto ErrorHandler &apos;Error comes from wrong parameter
Dim Y As Integer, M As Integer, Q As Integer, T As Variant, NumDate as Date
Dim M1 As Long, Cycle As Long, Phase As Long
NumDate = TheDate &apos;Force conversion or raise error
Milesian_DateElement NumDate, Y, M, Q, D   &apos;Compute the figures of the milesian date
&apos;Compute month rank from 1m of year 0
M1 = Y                     &apos; Force computation of month in Long
M1 = (M1 * 12) + MonthShift + M - 1 &apos;In this order, Long shall be before simple Integer
&apos;Compute year and month rank
Milesian_IntegDiv M1, 12, Cycle, Phase
Y = Cycle
M = Phase + 1
&apos;If Q was 31, set to end of month, else use same day number
If (((M Mod 2) = 1) Or ((M = 12) And Not MILESIAN_IS_LONG_YEAR(Y))) Then
Q = 30
Else: Q = 31
End If
MILESIAN_MONTH_END = MILESIAN_DATE(Y, M, Q)
Exit function
ErrorHandler:
MILESIAN_MONTH_END = InvalidNumber
End Function

&apos;#Part 6: Julian Day conversion functions

Function JULIAN_EPOCH_COUNT(TheDate)
&apos;A dared strategy: compute directly Julian count as if a date, but convert into a double before returning
	Dim Result As Double	
&apos;    Dim IntDate As Long, TimePart As Double
&apos;    TimePart = TheDate
&apos;    IntDate = Int(TimePart)  &apos;Integer part is Date at 00:00
&apos;    TimePart = TheDate - IntDate     &apos;Time in day
&apos;    TimePart = TimePart + 0.5       &apos;...shifted to Julian Day convention
&apos;    IntDate = IntDate + MStoJulianMinus05 &apos;Epoch shift
	Result = TheDate + MStoJulianMinus05 + 0.5
    JULIAN_EPOCH_COUNT = Result &apos;TimePart + IntDate
End Function

Function JULIAN_EPOCH_DATE(Julian_Count)
&apos;The strategy of computing directly to a Date object does not work: no Date computation inside a routine
    Dim IntDate As Long, TimePart As Double
    IntDate = Int(Julian_Count)       &apos;Integer part of Julian Day
    TimePart = Julian_Count - IntDate &apos;Decimal part, i.e. time after noon
    TimePart = TimePart + 0.5 &apos;Add, not substract, a half day
    IntDate = IntDate - MStoJulianMinus05 - 1 &apos;Compensate full day added from above
    JULIAN_EPOCH_DATE = TimePart + IntDate
End Function

Function DAYOFWEEK_Ext(TheDate As Date, Optional DispType As Integer) As Integer &apos;Milesian way: Sunday = 0, Monday = 1, up to Saturday = 6
    Dim IntDate As Long, Start As Integer, Phase As Integer
    
    &apos;1. Compute Start and Phase from DispType
    If IsMissing(DispType) Then DispType = 0    &apos;This option value is not used with standard DOW routines
    Phase = 6   &apos;The most common case: cycle starts with Sunday
    Select Case DispType
        Case 0          &apos;The Milesian, John Conway, the most simple to memorize
            Start = 0
        Case 1          &apos;The Spreadsheets&apos; standard
            Start = 1
        Case 2
            Start = 1
            Phase = Phase - 1
        Case 3
            Start = 0
            Phase = Phase - 1
        Case 11 To 17
            Start = 1
            Phase = Phase - (DispType - 10)
        Case Else
            Err.Raise 1
        End Select
    
    &apos;2. Extract Date element and compute
    IntDate = Int(TheDate)  &apos;Convert date-time to hold date component only
    DAYOFWEEK_Ext = PosMod(IntDate + Phase, 7) + Start
    
End Function

Sub Macro1

End Sub

Sub Macro2

End Sub</script:module>